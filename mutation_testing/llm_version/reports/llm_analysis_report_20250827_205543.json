{
  "timestamp": "2025-08-27T20:55:43.572571",
  "model_used": "microsoft/DialoGPT-medium",
  "files_analyzed": 2,
  "analyses": [
    {
      "filename": "sut.py",
      "llm_analysis": "",
      "model_used": "microsoft/DialoGPT-medium",
      "timestamp": "2025-08-27T20:55:41.940274",
      "suggested_mutations": [
        {
          "id": "intelligent_3",
          "description": "Alterar condição de None para detectar tratamento inadequado de valores nulos",
          "type": "comparison_operator"
        },
        {
          "id": "intelligent_4",
          "description": "Modificar validação de tipo para testar tratamento de tipos incorretos",
          "type": "comparison_operator"
        },
        {
          "id": "intelligent_6",
          "description": "Modificar tipo de erro para testar tratamento específico de exceções",
          "type": "exception_handling"
        },
        {
          "id": "intelligent_1",
          "description": "Alterar coeficiente de multiplicação de 2 para 3 para detectar testes que assumem valor fixo",
          "type": "arithmetic_operator"
        },
        {
          "id": "intelligent_2",
          "description": "Mudar operador de multiplicação para soma para testar robustez dos testes",
          "type": "arithmetic_operator"
        }
      ]
    },
    {
      "filename": "models.py",
      "llm_analysis": "",
      "model_used": "microsoft/DialoGPT-medium",
      "timestamp": "2025-08-27T20:55:43.572547",
      "suggested_mutations": [
        {
          "id": "intelligent_5",
          "description": "Alterar nome da tabela para detectar testes que dependem de nomes específicos",
          "type": "constant_replacement"
        },
        {
          "id": "fallback_1",
          "description": "Mutações inteligentes baseadas em análise estrutural do código",
          "type": "arithmetic_operator"
        },
        {
          "id": "fallback_2",
          "description": "Alterações em operadores condicionais para melhorar cobertura de testes",
          "type": "comparison_operator"
        },
        {
          "id": "fallback_3",
          "description": "Modificações em constantes para detectar dependências não testadas",
          "type": "constant_replacement"
        }
      ]
    }
  ],
  "generated_tests": [
    "\ndef test_comparison_operators(self):\n    \"\"\"Test generated by LLM: Alterar condição de None para detectar tratamento inadequado de valores nulos\"\"\"\n    sut = SystemUnderTest()\n\n    # Test boundary conditions that might be affected by comparison changes\n    boundary_values = [0, 1, -1, None]\n\n    for value in boundary_values:\n        if value is not None:\n            result = sut.function(value)\n            # Verify the function behaves correctly at boundaries\n            assert isinstance(result, (int, float)), f\"Result should be numeric for input {value}\"\n        else:\n            # Test None handling\n            result = sut.function(value)\n            assert result is None, \"function(None) should return None\"\n            ",
    "\ndef test_comparison_operators(self):\n    \"\"\"Test generated by LLM: Modificar validação de tipo para testar tratamento de tipos incorretos\"\"\"\n    sut = SystemUnderTest()\n\n    # Test boundary conditions that might be affected by comparison changes\n    boundary_values = [0, 1, -1, None]\n\n    for value in boundary_values:\n        if value is not None:\n            result = sut.function(value)\n            # Verify the function behaves correctly at boundaries\n            assert isinstance(result, (int, float)), f\"Result should be numeric for input {value}\"\n        else:\n            # Test None handling\n            result = sut.function(value)\n            assert result is None, \"function(None) should return None\"\n            ",
    "\ndef test_exception_handling_robustness(self):\n    \"\"\"Test generated by LLM: Modificar tipo de erro para testar tratamento específico de exceções\"\"\"\n    sut = SystemUnderTest()\n\n    # Test various invalid inputs that should raise TypeError\n    invalid_inputs = [\n        \"string\",\n        [1, 2, 3],\n        {\"key\": \"value\"},\n        True,\n        complex(1, 2)\n    ]\n\n    for invalid_input in invalid_inputs:\n        with pytest.raises(TypeError, match=\"Expected numeric\"):\n            sut.function(invalid_input)\n            ",
    "\ndef test_arithmetic_operation_integrity(self):\n    \"\"\"Test generated by LLM: Alterar coeficiente de multiplicação de 2 para 3 para detectar testes que assumem valor fixo\"\"\"\n    sut = SystemUnderTest()\n\n    # Test with values where different coefficients give different results\n    test_cases = [\n        (1, 2),    # 2*1 = 2, 3*1 = 3\n        (3, 6),    # 2*3 = 6, 3*3 = 9\n        (7, 14),   # 2*7 = 14, 3*7 = 21\n        (0.5, 1.0) # 2*0.5 = 1.0, 3*0.5 = 1.5\n    ]\n\n    for input_val, expected in test_cases:\n        result = sut.function(input_val)\n        assert result == expected, f\"function({input_val}) should return {expected} (exactly double), got {result}\"\n\n        # Additional check: ensure it's not triple or other coefficient\n        assert result != input_val * 3, f\"Result should not be triple: {input_val} * 3 = {input_val * 3}\"\n        ",
    "\ndef test_arithmetic_operation_integrity(self):\n    \"\"\"Test generated by LLM: Mudar operador de multiplicação para soma para testar robustez dos testes\"\"\"\n    sut = SystemUnderTest()\n\n    # Test with values where different coefficients give different results\n    test_cases = [\n        (1, 2),    # 2*1 = 2, 3*1 = 3\n        (3, 6),    # 2*3 = 6, 3*3 = 9\n        (7, 14),   # 2*7 = 14, 3*7 = 21\n        (0.5, 1.0) # 2*0.5 = 1.0, 3*0.5 = 1.5\n    ]\n\n    for input_val, expected in test_cases:\n        result = sut.function(input_val)\n        assert result == expected, f\"function({input_val}) should return {expected} (exactly double), got {result}\"\n\n        # Additional check: ensure it's not triple or other coefficient\n        assert result != input_val * 3, f\"Result should not be triple: {input_val} * 3 = {input_val * 3}\"\n        ",
    "\ndef test_constant_values(self):\n    \"\"\"Test generated by LLM: Alterar nome da tabela para detectar testes que dependem de nomes específicos\"\"\"\n    # This test would be specific to constants identified in the code\n    # For the SystemUnderTest, we focus on the multiplication coefficient\n    sut = SystemUnderTest()\n\n    # Test that the coefficient is exactly 2, not some other value\n    for i in range(1, 11):  # Test with multiple values\n        result = sut.function(i)\n        expected_double = i * 2\n        expected_triple = i * 3\n\n        assert result == expected_double, f\"Should be double: {i} * 2 = {expected_double}, got {result}\"\n        assert result != expected_triple, f\"Should not be triple: {i} * 3 = {expected_triple}\"\n        ",
    "\ndef test_arithmetic_operation_integrity(self):\n    \"\"\"Test generated by LLM: Mutações inteligentes baseadas em análise estrutural do código\"\"\"\n    sut = SystemUnderTest()\n\n    # Test with values where different coefficients give different results\n    test_cases = [\n        (1, 2),    # 2*1 = 2, 3*1 = 3\n        (3, 6),    # 2*3 = 6, 3*3 = 9\n        (7, 14),   # 2*7 = 14, 3*7 = 21\n        (0.5, 1.0) # 2*0.5 = 1.0, 3*0.5 = 1.5\n    ]\n\n    for input_val, expected in test_cases:\n        result = sut.function(input_val)\n        assert result == expected, f\"function({input_val}) should return {expected} (exactly double), got {result}\"\n\n        # Additional check: ensure it's not triple or other coefficient\n        assert result != input_val * 3, f\"Result should not be triple: {input_val} * 3 = {input_val * 3}\"\n        ",
    "\ndef test_comparison_operators(self):\n    \"\"\"Test generated by LLM: Alterações em operadores condicionais para melhorar cobertura de testes\"\"\"\n    sut = SystemUnderTest()\n\n    # Test boundary conditions that might be affected by comparison changes\n    boundary_values = [0, 1, -1, None]\n\n    for value in boundary_values:\n        if value is not None:\n            result = sut.function(value)\n            # Verify the function behaves correctly at boundaries\n            assert isinstance(result, (int, float)), f\"Result should be numeric for input {value}\"\n        else:\n            # Test None handling\n            result = sut.function(value)\n            assert result is None, \"function(None) should return None\"\n            ",
    "\ndef test_constant_values(self):\n    \"\"\"Test generated by LLM: Modificações em constantes para detectar dependências não testadas\"\"\"\n    # This test would be specific to constants identified in the code\n    # For the SystemUnderTest, we focus on the multiplication coefficient\n    sut = SystemUnderTest()\n\n    # Test that the coefficient is exactly 2, not some other value\n    for i in range(1, 11):  # Test with multiple values\n        result = sut.function(i)\n        expected_double = i * 2\n        expected_triple = i * 3\n\n        assert result == expected_double, f\"Should be double: {i} * 2 = {expected_double}, got {result}\"\n        assert result != expected_triple, f\"Should not be triple: {i} * 3 = {expected_triple}\"\n        "
  ],
  "summary": {
    "total_mutations_suggested": 9,
    "total_tests_generated": 9,
    "mutation_types": {
      "comparison_operator": 3,
      "exception_handling": 1,
      "arithmetic_operator": 3,
      "constant_replacement": 2
    }
  }
}